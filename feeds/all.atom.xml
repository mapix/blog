<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>qingchen</title><link href="http://qingchen.me/" rel="alternate"></link><link href="http://qingchen.me/feeds/all.atom.xml" rel="self"></link><id>http://qingchen.me/</id><updated>2013-04-14T23:50:00+02:00</updated><entry><title>WebPage Encoding Test</title><link href="http://qingchen.me/webpage_encoding_test.html" rel="alternate"></link><updated>2013-04-14T23:50:00+02:00</updated><author><name>qingchen</name></author><id>tag:qingchen.me,2013-04-14:webpage_encoding_test.html</id><summary type="html">&lt;p&gt;很多时候我们从搜索引擎跳转到一个新的站点的时候站点会作出一些站内引导，引导的方式其中有一类就是抓取搜索引擎的关键词，然后根据关键词引导，这个时候在跨站操作的过程中就出现了编码问题，以至于一些时候我们看到的引导词是乱码的，在这种情况下，网站要想更好的引导用户，就需要尽最大可能的处理好encoding的问题。而从web传递进来的字符本身是没有任何编码信息的，真实的编码信息由于OS和WebBrowser的不同而不同，这个时候其实就需要有个选择的过程。&lt;/p&gt;
&lt;p&gt;首先，需要明确自己网站的编码是什么，现如今大部分是UTF-8，当然不乏一些大网站还是用的GBK，下面使用Python演示一下自动处理这个问题的一些代码片段, 应该根据自己站点用户使用浏览器，OS的情况稍微做一些调查，然后列出一个可用的列表，原则上，排第一个的应该是站点自己的编码，其次是多字节的编码，然后是单字节编码，其中类似Latin1这种编码，占据全部8位的空间，所以需要放在最后一位，因为对它来说，什么都是编码正确的。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;CHARSETS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                  &lt;span class="c"&gt;# Unicode多语言&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;gb18030&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;         &lt;span class="c"&gt;# 简体中文 &lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;big5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                   &lt;span class="c"&gt;# 繁体中文， 台湾香港澳门&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;EUC_KR&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                 &lt;span class="c"&gt;# 韩语&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;EUC_JP&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Shift_JIS&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c"&gt;# 日语&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;KOI8-R&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Windows-1251&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;# 俄语&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;iso-8859-5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c"&gt;# 斯拉夫语系(保加利亚语,Byelorussian语,马其顿语,俄语,塞尔维亚语,乌克兰语等)&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;iso-8859-2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c"&gt;# 中欧语系&lt;/span&gt;
  &lt;span class="s"&gt;&amp;#39;iso-8859-1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;             &lt;span class="c"&gt;# 西欧语系(荷兰语,英语,法语,德语,意大利语,挪威语,葡萄牙语,瑞士语.等十八种语言), Latin1 &lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;处理的逻辑很简单，就是遍历之前的这个决策列表，除非有解码异常，否则就认为识别编码。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;detect_charset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;#39;&amp;#39;&amp;#39;事实上，一个rawstr 过来是无法确定它是什么东西的， It all depends&amp;#39;&amp;#39;&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;unicode&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;charset&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;CHARSETS&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;charset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;except&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;pass&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里你可能想到了chardet等专门用于探测字符编码的库来完成，但是这些基于规则的探测库只有在大量输入的情况下才能形成统计结论，而对于这种一个两个搜索词的缺毫无办法。函数完成了，就需要看到对其进行一个测试了，这里使用Python的标准库模拟从百度过来一个搜索:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib2&lt;/span&gt;
&lt;span class="n"&gt;referer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://www.baidu.com/s?wd=Hello&amp;amp;rsv_spt=1&amp;amp;issp=1&amp;amp;rsv_bp=0&amp;amp;ie=utf-8&amp;amp;tn=baiduhome_pg&amp;amp;rsv_sug3=3&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;req&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;origin_url&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Referer&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;referer&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样通过这个web地址就可以对页面识别搜索引擎关键词做出模拟，而在这里的wd参数也可替换成自己需要的编码，例如：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;你好&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;gbk&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\xc4\xe3\xba\xc3&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\xe4\xbd\xa0\xe5\xa5\xbd&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要测试其他编码的时候只需要将上面得到的编码后的字符替换上面的Hello就可以了。&lt;/p&gt;
&lt;p&gt;还有一个手动测试编码的好方法，以豆瓣小组匿名引导为例，步骤如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Firefox 匿名状态下打开豆瓣搜索页面，注意在豆瓣搜索页面有个搜索的Form;&lt;/li&gt;
&lt;li&gt;更改这个页面的编码为你需要测试的编码，这个时候Form要处理的编码会随着你的设定而走;&lt;/li&gt;
&lt;li&gt;在乱码的网页那个搜索Form里边输入需要测试的搜索词&lt;code&gt;你好&lt;/code&gt;, 点击提交; &lt;/li&gt;
&lt;li&gt;这个时候结果页是编码正常的，也能顺利搜索到内容，但搜索框里边的搜索词与你搜索的&lt;code&gt;你好&lt;/code&gt;又相去甚远，不过不用沮丧，因为你已经得到了一个你设定编码的reffer了;&lt;/li&gt;
&lt;li&gt;在这个页面点击搜索出来的小组，小组会弹出匿名引导框，这个时候再看匿名引导框上的文字&lt;code&gt;你好&lt;/code&gt;又好了;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程其实就是应用到了之前说过的那个多级解码的函数了， 第4步的时候其实我们是获取了一个可用的需要测试编码内容的reffer了，再进入下一个页面的时候，会自带reffer信息，就被这个函数成功处理了。&lt;/p&gt;</summary><category term="Test"></category><category term="Encoding"></category><category term="Python"></category></entry></feed>